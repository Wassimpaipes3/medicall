rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function: Format current date as "YYYY-MM-DD"
    function currentDate() {
      return string(request.time.year) + '-' +
             (request.time.month < 10 ? '0' + string(request.time.month) : string(request.time.month)) + '-' +
             (request.time.date < 10 ? '0' + string(request.time.date) : string(request.time.date));
    }

    // === /users: Basic user metadata (role, email, name) ===
    match /users/{userId} {
      // Allow any authenticated user to read basic profile info (for displaying provider names/photos)
      allow read: if request.auth != null;
      // Only the user can write to their own document
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // === /patients: Medical & personal data (sensitive!) ===
    match /patients/{patientId} {
      // Allow patient to read/write their own profile
      // ALSO allow providers to read patient basic info (name, avatar, etc.) for chat list
      allow read: if request.auth != null && (
        request.auth.uid == patientId  // Patient can read own data
        || exists(/databases/$(database)/documents/professionals/$(request.auth.uid))  // Providers can read
      );
      
      allow write: if request.auth != null && request.auth.uid == patientId;

      // On create: must match UID and have correct role
      allow create: if request.auth != null
        && request.auth.uid == patientId
        && request.resource.data.userId == patientId
        && request.resource.data.role == 'patient'
        // Validate required medical fields exist
        && request.resource.data.allergies is string
        && request.resource.data.antecedents is string
        && request.resource.data.groupe_sanguin is string
        && request.resource.data.dossiers_medicaux is string
        && request.resource.data.notifications_non_lues is int;

      // === /patients/{patientId}/savedLocations: Patient's saved addresses ===
      match /savedLocations/{locationId} {
        // Allow patient to read/write their own saved locations
        allow read, write: if request.auth != null && request.auth.uid == patientId;
        
        // Allow create with validation
        allow create: if request.auth != null 
          && request.auth.uid == patientId
          && request.resource.data.name is string
          && request.resource.data.address is string
          && request.resource.data.latitude is number
          && request.resource.data.longitude is number;
      }
    }

    // === /professionals: Unified rules for professionals ===
    match /professionals/{proId} {
      allow read: if request.auth != null;

      allow create: if request.auth != null
        && (request.auth.uid == proId || request.resource.data.id_user == request.auth.uid)
        && request.resource.data.profession in ['medecin', 'infirmier', 'doctor', 'nurse'];

      // Allow professional to update their own profile
      // OR allow any authenticated user to update rating/reviewsCount (for review system)
      allow update: if request.auth != null && (
        // Professional updating their own profile
        (request.auth.uid == proId || resource.data.id_user == request.auth.uid)
        ||
        // Anyone can update rating fields (review system)
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['rating', 'reviewsCount']))
      );
            
      allow delete: if request.auth != null
        && (request.auth.uid == proId || resource.data.id_user == request.auth.uid);
    }

    // === /providers: Legacy provider documents (for cleanup) ===
    match /providers/{proId} {
      // Allow read for all authenticated users  
      allow read: if request.auth != null;
      
      // Allow write for the provider themselves or during role changes
      allow write: if request.auth != null && request.auth.uid == proId;
    }

    // === /role_change_log: Audit trail for role changes ===
    match /role_change_log/{logId} {
      // Allow read for admins or the affected user
      allow read: if request.auth != null;
      
      // Allow create for role change operations
      allow create: if request.auth != null;
    }

    // === /disponibilites: Professional availability slots ===
    match /disponibilites/{id_dispo} {
      allow read: if request.auth != null;

      allow create: if request.auth != null
        && request.resource.data.idpro == request.auth.uid
        && exists(/databases/$(database)/documents/professionnels/$(request.auth.uid));

      allow update, delete: if request.auth != null
        && resource.data.idpro == request.auth.uid;
    }

    // === /appointments: Appointment booking system ===
    match /appointments/{appId} {
      // Allow authenticated users to list appointments (for queries)
      // Individual document access is still restricted by the read rule below
      allow list: if request.auth != null;
      
      // Allow reading specific appointments only if user is involved
      allow get: if request.auth != null &&
        (resource.data.patientId == request.auth.uid || 
         resource.data.professionnelId == request.auth.uid ||
         resource.data.idpat == request.auth.uid || 
         resource.data.idpro == request.auth.uid);

      // Allow authenticated users (patient or provider) to create appointments
      allow create: if request.auth != null &&
        (request.resource.data.idpat == request.auth.uid || 
         request.resource.data.idpro == request.auth.uid ||
         request.resource.data.patientId == request.auth.uid ||
         request.resource.data.professionnelId == request.auth.uid);

      // Allow patient or provider to update their own appointments
      // (for location tracking, status updates, etc.)
      allow update: if request.auth != null
        && (resource.data.patientId == request.auth.uid || 
            resource.data.professionnelId == request.auth.uid ||
            resource.data.idpat == request.auth.uid || 
            resource.data.idpro == request.auth.uid);
      
      // Only allow deletion if status is pending or cancelled
      allow delete: if request.auth != null
        && (resource.data.patientId == request.auth.uid || 
            resource.data.professionnelId == request.auth.uid ||
            resource.data.idpat == request.auth.uid || 
            resource.data.idpro == request.auth.uid)
        && resource.data.status in ['pending', 'cancelled'];
    }

    // === /provider_requests: Pre-appointment provider selection ===
    match /provider_requests/{reqId} {
      // Allow read for authenticated users (patient or provider involved)
      allow read: if request.auth != null;

      // Patient creates request targeting a provider
      allow create: if request.auth != null &&
        (
          request.resource.data.patientId == request.auth.uid ||
          request.resource.data.idpat == request.auth.uid
        );

      // Updates: patient can cancel while pending; provider can accept OR decline
      allow update: if request.auth != null && (
        // Patient cancellation
        (resource.data.patientId == request.auth.uid && resource.data.status == 'pending' && request.resource.data.status in ['cancelled','pending']) ||
        // Provider acceptance or decline
        (resource.data.providerId == request.auth.uid && resource.data.status == 'pending' && request.resource.data.status in ['accepted', 'declined'])
      );

      // Allow deletion by Cloud Functions (for TTL cleanup) or by involved users
      allow delete: if request.auth != null;
    }

    // === /avis: Patient reviews for professionals ===
    match /avis/{id_avis} {
      // Anyone authenticated can read reviews
      allow read: if request.auth != null;

      // TEMPORARY: Allow ANY authenticated user to create reviews (for testing)
      // TODO: Add back validation once basic write works
      allow create: if request.auth != null;

      // Allow update and delete by anyone authenticated (for testing)
      allow update, delete: if request.auth != null;
    }

    // === /notifications: User-specific alerts ===
    match /notifications/{notifId} {
      allow read: if request.auth != null
        && resource.data.destinataire == request.auth.uid;

      // Allow users to update their own notifications (mark as read)
      allow update: if request.auth != null
        && resource.data.destinataire == request.auth.uid
        && request.resource.data.destinataire == resource.data.destinataire; // Cannot change owner

      // Allow users to delete their own notifications
      allow delete: if request.auth != null
        && resource.data.destinataire == request.auth.uid;

      // Only Cloud Functions can create notifications
      allow create: if false;
    }

    // === /chats: Real-time messaging system ===
    match /chats/{chatId} {
      // Helper function to check if user is a participant
      function isParticipant() {
        return request.auth != null && 
               request.auth.uid in resource.data.participants;
      }

      // Helper function to check if user is a participant for new chats
      function isNewParticipant() {
        return request.auth != null && 
               request.auth.uid in request.resource.data.participants;
      }

      // Allow read if user is a participant in the chat
      // Also allow reading if chat doesn't exist (for checking existence)
      allow read: if request.auth != null && 
                     (resource == null || request.auth.uid in resource.data.participants);
      
      // Allow create if user is a participant in the new chat
      allow create: if request.auth != null && 
                       request.auth.uid in request.resource.data.participants &&
                       request.resource.data.participants is list &&
                       request.resource.data.participants.size() == 2;
      
      // Allow update if user is a participant (for lastMessage updates)
      allow update: if request.auth != null && 
                       request.auth.uid in resource.data.participants;
      
      // Allow delete if user is a participant
      allow delete: if request.auth != null && 
                       request.auth.uid in resource.data.participants;
      
      // === /chats/{chatId}/messages: Individual messages ===
      match /messages/{messageId} {
        // Helper function to check parent chat exists and user is participant
        function isParticipantInChat() {
          let chat = get(/databases/$(database)/documents/chats/$(chatId));
          return request.auth != null && 
                 chat != null && 
                 request.auth.uid in chat.data.participants;
        }
        
        // Allow read if user is participant in parent chat
        allow read: if isParticipantInChat();
        
        // Allow create if user is participant and is the sender
        allow create: if isParticipantInChat() &&
                         request.resource.data.senderId == request.auth.uid;
        
        // Allow update if user is participant (for marking messages as seen)
        // This allows ANY participant to update (mark as read), not just the sender
        allow update: if isParticipantInChat();
        
        // Allow delete if user is participant
        allow delete: if isParticipantInChat();
      }
    }
  }
}